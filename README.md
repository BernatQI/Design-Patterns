# üéØ Patrones de Dise√±o - Design Patterns

Una colecci√≥n completa de **Patrones de Dise√±o** implementados en **TypeScript** con ejemplos pr√°cticos, diagramas UML y c√≥digo ejecutable. Este repositorio est√° dise√±ado para aprender y entender los patrones fundamentales de la programaci√≥n orientada a objetos.

## üìã ¬øQu√© son los Patrones de Dise√±o?

Los **Patrones de Dise√±o** son soluciones reutilizables a problemas comunes en el dise√±o de software. Representan las mejores pr√°cticas utilizadas por desarrolladores experimentados y proporcionan un vocabulario com√∫n para discutir soluciones de dise√±o.

### Beneficios:
- üîÑ **Reutilizaci√≥n**: Soluciones probadas y testadas
- üìñ **Comunicaci√≥n**: Vocabulario com√∫n entre desarrolladores  
- üèóÔ∏è **Estructura**: Mejor organizaci√≥n y arquitectura del c√≥digo
- üõ°Ô∏è **Mantenibilidad**: C√≥digo m√°s f√°cil de mantener y extender

## üó∫Ô∏è Clasificaci√≥n de Patrones

```mermaid
graph TD
    A[Patrones de Dise√±o] --> B[Creacionales]
    A --> C[Estructurales]  
    A --> D[Comportamentales]
    
    B --> B1[Singleton]
    B --> B2[Factory Method]
    B --> B3[Abstract Factory]
    B --> B4[Builder]
    B --> B5[Prototype]
    
    C --> C1[Adapter]
    C --> C2[Bridge]
    C --> C3[Composite]
    C --> C4[Decorator]
    C --> C5[Facade]
    C --> C6[Flyweight]
    C --> C7[Proxy]
    
    D --> D1[Observer]
    D --> D2[Strategy]
    D --> D3[Command]
    D --> D4[State]
    D --> D5[Template Method]
    D --> D6[Chain of Responsibility]
    D --> D7[Mediator]
    D --> D8[Memento]
    D --> D9[Visitor]
    D --> D10[Iterator]
    D --> D11[Interpreter]
    
    classDef implemented fill:#4CAF50,stroke:#2E7D32,color:#fff
    classDef pending fill:#FF9800,stroke:#F57C00,color:#fff
    
    class B1,B2,B3,B4,B5,C1,C2 implemented
    class C3,C4,C5,C6,C7,D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11 pending
```

## üöÄ C√≥digo Ejecutable de Ejemplo

Aqu√≠ tienes un ejemplo pr√°ctico que muestra c√≥mo diferentes patrones trabajan juntos:

```typescript
// Ejemplo integrado: Sistema de Notificaciones con m√∫ltiples patrones

// 1. SINGLETON: Configuraci√≥n global del sistema
class NotificationConfig {
    private static instance: NotificationConfig;
    private settings = {
        emailEnabled: true,
        smsEnabled: true,
        slackEnabled: true,
        maxRetries: 3
    };
    
    static getInstance(): NotificationConfig {
        if (!this.instance) {
            this.instance = new NotificationConfig();
        }
        return this.instance;
    }
    
    getSettings() { return this.settings; }
}

// 2. ABSTRACT FACTORY: Diferentes tipos de notificadores
abstract class NotificationFactory {
    abstract createEmailSender(): INotificationSender;
    abstract createSMSSender(): INotificationSender;
    abstract createSlackSender(): INotificationSender;
}

class ProductionNotificationFactory extends NotificationFactory {
    createEmailSender(): INotificationSender {
        return new EmailSender();
    }
    createSMSSender(): INotificationSender {
        return new SMSSender();
    }
    createSlackSender(): INotificationSender {
        return new SlackSender();
    }
}

// 3. BRIDGE: Separaci√≥n entre abstracci√≥n (tipo notificaci√≥n) e implementaci√≥n (canal)
abstract class Notification {
    constructor(protected sender: INotificationSender) {}
    abstract send(message: string): void;
}

class UrgentNotification extends Notification {
    send(message: string): void {
        console.log("üö® URGENTE:");
        this.sender.send(`[URGENTE] ${message}`);
    }
}

class SimpleNotification extends Notification {
    send(message: string): void {
        console.log("üì¢ Notificaci√≥n:");
        this.sender.send(message);
    }
}

// 4. ADAPTER: Integrar servicio externo incompatible
class SlackAPIAdapter implements INotificationSender {
    private slackAPI = new ThirdPartySlackAPI();
    
    send(message: string): void {
        // Adaptar interfaz incompatible
        const slackMessage = {
            text: message,
            channel: "#general",
            username: "NotificationBot"
        };
        this.slackAPI.postMessage(slackMessage);
    }
}

// 5. BUILDER: Construcci√≥n compleja de notificaciones
class NotificationBuilder {
    private notification: ComplexNotification = new ComplexNotification();
    
    withRecipient(recipient: string): NotificationBuilder {
        this.notification.addRecipient(recipient);
        return this;
    }
    
    withTemplate(template: string): NotificationBuilder {
        this.notification.setTemplate(template);
        return this;
    }
    
    withPriority(priority: 'low' | 'medium' | 'high'): NotificationBuilder {
        this.notification.setPriority(priority);
        return this;
    }
    
    build(): ComplexNotification {
        return this.notification;
    }
}

// 6. PROTOTYPE: Clonar configuraciones de notificaci√≥n
class NotificationTemplate {
    constructor(
        public type: string,
        public subject: string,
        public body: string,
        public metadata: Map<string, any>
    ) {}
    
    clone(): NotificationTemplate {
        return new NotificationTemplate(
            this.type,
            this.subject,
            this.body,
            new Map(this.metadata)
        );
    }
}

// USO INTEGRADO DE TODOS LOS PATRONES
function demonstratePatterns(): void {
    console.log("üéØ === DEMOSTRACI√ìN DE PATRONES DE DISE√ëO ===\n");
    
    // 1. Singleton: Configuraci√≥n √∫nica
    const config = NotificationConfig.getInstance();
    console.log("üìã Configuraci√≥n del sistema:", config.getSettings());
    
    // 2. Abstract Factory: Crear familia de notificadores
    const factory = new ProductionNotificationFactory();
    const emailSender = factory.createEmailSender();
    const smsSender = factory.createSMSSender();
    
    // 3. Bridge: Diferentes abstracciones con misma implementaci√≥n
    const urgentEmail = new UrgentNotification(emailSender);
    const simpleSMS = new SimpleNotification(smsSender);
    
    urgentEmail.send("Sistema comprometido - Revisar inmediatamente");
    simpleSMS.send("Reporte diario generado exitosamente");
    
    // 4. Adapter: Integrar servicio externo
    const slackAdapter = new SlackAPIAdapter();
    const slackNotification = new SimpleNotification(slackAdapter);
    slackNotification.send("Nuevo deploy realizado en producci√≥n");
    
    // 5. Builder: Construir notificaci√≥n compleja
    const complexNotification = new NotificationBuilder()
        .withRecipient("admin@company.com")
        .withRecipient("ops@company.com")
        .withTemplate("security-alert")
        .withPriority("high")
        .build();
    
    console.log("üîß Notificaci√≥n compleja:", complexNotification);
    
    // 6. Prototype: Clonar template
    const alertTemplate = new NotificationTemplate(
        "security",
        "Alerta de Seguridad",
        "Se detect√≥ actividad sospechosa",
        new Map([["severity", "high"], ["department", "IT"]])
    );
    
    const clonedTemplate = alertTemplate.clone();
    clonedTemplate.metadata.set("timestamp", new Date().toISOString());
    
    console.log("üìÑ Template original:", alertTemplate);
    console.log("üìÑ Template clonado:", clonedTemplate);
    
    console.log("\n‚úÖ ¬°Demostraci√≥n completada! Todos los patrones trabajando juntos.");
}

// EJECUTAR DEMOSTRACI√ìN
demonstratePatterns();
```

### üèÉ‚Äç‚ôÇÔ∏è C√≥mo Ejecutar los Ejemplos

```bash
# Clonar el repositorio
git clone https://github.com/BernatQI/Design-Patterns.git
cd Design-Patterns

# Instalar dependencias (si es necesario)
npm install

# Ejecutar un patr√≥n espec√≠fico
npx ts-node prototype/Main.ts
npx ts-node singleton/Main.ts
npx ts-node bridge/Main.ts

# O compilar y ejecutar
npx tsc --project singleton/tsconfig.json
node singleton/Main.js
```

## üìö Patrones Implementados

### üèóÔ∏è Patrones Creacionales
Estos patrones se enfocan en la **creaci√≥n de objetos**, proporcionando mecanismos que aumentan la flexibilidad y reutilizaci√≥n del c√≥digo.

| Patr√≥n | Descripci√≥n | Estado |
|--------|-------------|---------|
| [**Singleton**](./singleton/) | Garantiza una √∫nica instancia de una clase | ‚úÖ Implementado |
| [**Factory Method**](./factory/) | Crea objetos sin especificar clases exactas | ‚úÖ Implementado |
| [**Abstract Factory**](./abstract-factory/) | Crea familias de objetos relacionados | ‚úÖ Implementado |
| [**Builder**](./builder/) | Construye objetos complejos paso a paso | ‚úÖ Implementado |
| [**Prototype**](./prototype/) | Crea objetos clonando instancias existentes | ‚úÖ Implementado |

### üîó Patrones Estructurales
Estos patrones se enfocan en la **composici√≥n de clases y objetos**, formando estructuras m√°s grandes mientras mantienen flexibilidad y eficiencia.

| Patr√≥n | Descripci√≥n | Estado |
|--------|-------------|---------|
| [**Adapter**](./adapter/) | Permite que interfaces incompatibles trabajen juntas | ‚úÖ Implementado |
| [**Bridge**](./bridge/) | Separa abstracci√≥n de implementaci√≥n | ‚úÖ Implementado |
| **Composite** | Compone objetos en estructuras de √°rbol | üîÑ (pr√≥ximamente) |
| **Decorator** | A√±ade comportamiento a objetos din√°micamente | üîÑ (pr√≥ximamente) |
| **Facade** | Proporciona interfaz simplificada a subsistema complejo | üîÑ (pr√≥ximamente) |
| **Flyweight** | Minimiza uso de memoria compartiendo datos eficientemente | üîÑ (pr√≥ximamente) |
| **Proxy** | Proporciona sustituto o placeholder para otro objeto | üîÑ (pr√≥ximamente) |

### üé≠ Patrones Comportamentales
Estos patrones se enfocan en la **comunicaci√≥n entre objetos** y la asignaci√≥n de responsabilidades entre ellos.

| Patr√≥n | Descripci√≥n | Estado |
|--------|-------------|---------|
| **Observer** | Define dependencia uno-a-muchos entre objetos | üîÑ (pr√≥ximamente) |
| **Strategy** | Define familia de algoritmos intercambiables | üîÑ (pr√≥ximamente) |
| **Command** | Encapsula una solicitud como un objeto | üîÑ (pr√≥ximamente) |
| **State** | Permite que objeto altere comportamiento cuando cambia estado | üîÑ (pr√≥ximamente) |
| **Template Method** | Define esqueleto de algoritmo en clase base | üîÑ (pr√≥ximamente) |
| **Chain of Responsibility** | Pasa solicitudes a lo largo de cadena de manejadores | üîÑ (pr√≥ximamente) |
| **Mediator** | Define c√≥mo interact√∫a un conjunto de objetos | üîÑ (pr√≥ximamente) |
| **Memento** | Captura y restaura estado interno de objeto | üîÑ (pr√≥ximamente) |
| **Visitor** | Separa algoritmos de objetos sobre los que operan | üîÑ (pr√≥ximamente) |
| **Iterator** | Proporciona forma de acceder secuencialmente a elementos | üîÑ (pr√≥ximamente) |
| **Interpreter** | Define representaci√≥n para gram√°tica de lenguaje | üîÑ (pr√≥ximamente) |

## üéì Gu√≠a de Aprendizaje Recomendada

### üìà Nivel Principiante
1. **Singleton** - Concepto fundamental de instancia √∫nica
2. **Factory Method** - Introducci√≥n a la creaci√≥n de objetos
3. **Adapter** - Resolver incompatibilidades entre interfaces

### üìä Nivel Intermedio  
4. **Builder** - Construcci√≥n compleja de objetos
5. **Bridge** - Separaci√≥n de abstracci√≥n e implementaci√≥n
6. **Prototype** - Clonaci√≥n y gesti√≥n de prototipos

### üèÜ Nivel Avanzado
7. **Abstract Factory** - Familias complejas de objetos
8. **Observer** - Comunicaci√≥n entre m√∫ltiples objetos
9. **Strategy** - Algoritmos intercambiables
10. **Command** - Encapsulaci√≥n de operaciones

## üîç Caracter√≠sticas de cada Implementaci√≥n

Cada patr√≥n en este repositorio incluye:

- üìä **Diagrama UML** detallado en Mermaid
- üéØ **Problema espec√≠fico** que resuelve el patr√≥n
- ‚úÖ **C√≥digo TypeScript** completamente funcional
- üß™ **Ejemplos pr√°cticos** del mundo real
- üìù **Documentaci√≥n exhaustiva** con casos de uso
- ‚ö° **C√≥digo ejecutable** para probar inmediatamente
- üîó **Relaciones** con otros patrones
- üí° **Mejores pr√°cticas** y consideraciones

## üõ†Ô∏è Tecnolog√≠as Utilizadas

- **TypeScript** - Tipado fuerte y caracter√≠sticas modernas
- **Node.js** - Entorno de ejecuci√≥n 
- **Mermaid** - Diagramas UML integrados en markdown
- **ts-node** - Ejecuci√≥n directa de TypeScript

## üìñ Recursos Adicionales

### üìö Libros Recomendados
- **"Design Patterns: Elements of Reusable Object-Oriented Software"** - Gang of Four (GoF)
- **"Head First Design Patterns"** - Eric Freeman & Elisabeth Robson
- **"Refactoring: Improving the Design of Existing Code"** - Martin Fowler

### üåê Referencias Online
- [Refactoring Guru - Design Patterns](https://refactoring.guru/design-patterns)
- [SourceMaking - Design Patterns](https://sourcemaking.com/design_patterns)
- [DoFactory - Design Patterns](https://www.dofactory.com/net/design-patterns)

## ü§ù Contribuir

¬øQuieres contribuir? ¬°Genial! Aqu√≠ hay algunas formas:

1. üêõ **Reportar bugs** o problemas en los ejemplos
2. üí° **Sugerir mejoras** en la documentaci√≥n
3. üîß **Implementar patrones faltantes**
4. üìù **Mejorar explicaciones** existentes
5. üß™ **A√±adir m√°s ejemplos** pr√°cticos

### Proceso de Contribuci√≥n:
1. Fork el repositorio
2. Crea una rama para tu feature (`git checkout -b feature/nuevo-patron`)
3. Commit tus cambios (`git commit -am 'A√±adir patr√≥n Strategy'`)
4. Push a la rama (`git push origin feature/nuevo-patron`)
5. Abre un Pull Request

## üìÑ Licencia

Este proyecto est√° bajo la licencia MIT. Ver el archivo [LICENSE](LICENSE) para m√°s detalles.

## üë®‚Äçüíª Autor

**Bernat QI** - [GitHub](https://github.com/BernatQI)

---

‚≠ê **¬øTe result√≥ √∫til este repositorio?** ¬°Dale una estrella y comp√°rtelo!

üí¨ **¬øTienes preguntas?** Abre un issue y te ayudaremos.

üöÄ **¬øQuieres m√°s contenido?** S√≠gueme para estar al d√≠a con nuevos patrones y ejemplos.